## RabbitMQ

## AMQP
```Advanced Message Queuing Protocol```/高级消息队列协议

### AMQP的重要概念

* Server/Broker
    
    接收客户端的连接，实现AMQP实体服务。

* Connection

    连接，应用程序与Server的网络连接，TCP连接。

* Channel：

    信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。

* Message
    
    消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。
    
    * Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；
    
    * Body就是消息体内容。

* Virtual Host

    虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。

    
* Exchange

    交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种

* Binding

    绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。

* RoutingKey

    路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”。

* Queue
    
    消息队列，用来保存消息，供消费者消费。


### 组成部分

* 生产者
* 消费者
* 服务端

### 交换器

```Exchange```

四种类型

1. ```direct Exchange```/直接式交换器

    该类型的交换器将所有发送到该交换器的消息被转发到RoutingKey指定的队列中，也就是说路由到BindingKey和RoutingKey**完全匹配**的队列中。

    **一对一的，点对点的发送**

2. ```Topic Exchange```/主题式交换器

    该类型的交换器将所有发送到Topic Exchange的消息被转发到所有RoutingKey中指定的Topic的队列上面


3. ```Fanout Exchange```/广播式交换器

    该类型不处理路由键，会把所有发送到交换器的消息路由到所有绑定的队列中。优点是转发消息最快，性能最好。

    简单点说就是**发布订阅**

4. Headers Exchange

    该类型的交换器不依赖路由规则来路由消息，而是**根据消息内容中的headers属性进行匹配**。headers类型交换器**性能差**，在实际中并不常用。

### 消息确认模式

* 自动模式

    只要消息从队列获取,无论消费者获取到消息后是否成功消费,都认为是消息成功消费

* **手动模式**

    消费从队列中获取消息后,服务器会将该消息处于不可用状态,等待消费者反馈。如果消费者在消费过程中出现异常，断开连接切没有发送应答，那么RabbitMQ会将这个消息重新投递。


### 消费端限流

rabbitmq 服务器上有上万条未处理的消息，我们随便打开一个消费者的客户端，会出现下面的情况， 巨量的消息瞬间全部推送过来，但是我们的单个客户端无法同时处理这么多数据，这时候就需要在消费端进行限流操作，以此来保障消费端服务的稳定性。

RabbitMq 提供了一种qos(服务质量保证) 功能， 即在非自动确认消息的前提下，如果一定数目的消息（通过基于consume或者channel设置Qos 的值）**未被确认前，不进行消费新的消息**。如果是在限流的情况下，一定不能设置自动签收，autoAck = false; 一定要手动地进行消费。如果自动签收，就达不到限流的效果了。

 