##　重排序

* 指令重排序

* 内存重排序

### 内存重排序
<!-- 
https://cloud.tencent.com/developer/article/1857174 -->


缓存一致性协议

如果是一个写内存操作，必须通过通过总线广播一条消息我要修改某个地址了，然后让其它CPU更新或者删除自己的缓存，等所有其它CPU将自己缓存的数据更新后，才返回成功。

**写缓冲**/```Store buffer```

**无效队列**/```Invalidate Queue```

![无效队列](https://ask.qcloudimg.com/http-save/yehe-1519604/431393776f29fbeaccfba4e0dac75f69.png?imageView2/2/w/2560/h/7000)

1. 如果Cache中无数据，直接写入Cache，无需广播消息；

当然这里的Cache中无数据是每个Cpu的Cache都无数据，Cache一致性协议中有相关保障

2. 如果Cache中有数据则写入写缓存器，然后就直接返回了

3. CPU再异步将写缓存器里的数据同步到其它CPU，这样就保证最终一致性了

这样可以加大写内存指令的速度了，因为不用广播消息，并且等待每个CPU的返回。

同样，这样也带来了新的问题，如果在写入指令写入高速缓存后，缓存的数据还没同步到其它CPU中，那其它CPU就有可能会读到脏数据。

内存重排序

内存重排序实际上并不是真的相关操作被排序了，而是因为CPU引入缓存还没来得及刷新导致；

2、每个CPU都有自己的缓存，为了提高共享变量的写操作，CPU把整个操作变成异步的了，如果写入操作还没来的及同步到其它CPU，就有可能发生其它CPU读取到的是旧的值，因此看起来这条指令还没执行一样

分类

* LoadLoad重排序

* LoadStore重排序

* StoreStore重排序

* StoreLoad重排序

![重排序-内存屏障](https://img2023.cnblogs.com/blog/999484/202303/999484-20230329213422211-1427435665.png)

