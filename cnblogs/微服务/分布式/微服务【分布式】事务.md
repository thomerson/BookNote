## 分布式事务

> 保证单个完整操作的原子性

### CAP理论

分布式计算环境下，有3个核心的需求：

1. 一致性（Consistency）：再分布，所有实例节点同一时间看到是相同的数据

2. 可用性（Availability）：不管是否成功，确保每一个请求都能接收到响应

3. 分区容错性（Partition Tolerance）：系统任意分区后，在网络故障时，仍能操作

### CAP的组合情况

1. ```CA```: 放弃分区容错性。非分布式架构，比如关系数据库，因为没有分区，但是在分布式系统下，CA组合就不建议了

2. ```AP```: 放弃强一致性。追求最终一致性，类似的场景比如转账，可以接受两小时后到账，Eureka的注册也是类似的做法。 

3. ```CP```: 放弃可用性。zookeeper在leader宕机后，选举期间是不提供服务的。类似的场景比如支付完成之后出订单，必须一进一出都完成才行。 

在分布式系统中AP运用的最多，因为他放弃的是强一致性，追求的是**最终一致性**，性价比最高


### 数据一致性模型

1. 强一致性

当用户的操作完成之后，会**立马同步**到不同的数据副本中，后续其他任意请求都会获得更新过的值。这种对用户的可见性是最友好的，能始终保证读到正确的值。根据 CAP 理论，这种实现需要牺牲可用性。


2. 弱一致性

系统并不保证所有请求的访问都会获得最新值。数据写入成功之后，不承诺立即可以读，也不承诺具体多久之后可以读到，甚至读不到。在请求获得数据更新的这段时间，我i们称之为“不一致性窗口”。

3. 最终一致性

是弱一致性的一种。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。

## 分布式事务解决方案

1.  两阶段提交协议/2PC/Two-phase commit protocol

* 准备阶段
    * Undo Log(撤销)
    * Redo Log(重做)

* 提交阶段


2. 三阶段提交/Three-phase commit protocol/3PC

* 引入超时机制

* 同时在协调者和参与者中都引入超时机制

* 阶段
    * CanCommit

    * PreCommit

    * DoCommit

3. TCC事务

> Try Confirm Cancel

2PC和3PC都是数据库层面，而TCC是业务层面的分布式事务

如果有一个服务try出问题，整个事务管理器就执行cancel，如果try都成功，才执行confirm做正式提交


[.Net Core实现分布式事务]()

